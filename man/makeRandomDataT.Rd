% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/makeRandomDataT.R
\name{makeRandomDataT}
\alias{makeRandomDataT}
\title{makeRandomDataT}
\usage{
makeRandomDataT(n, maxD, minD = 0, minObsA = 30,
  func.distW = c("uniformW", "normalW", "bernoulliW", "binomialW", "gammaW",
  "normalWCor", "bernoulliWCor", "uniformWCor", "gammaPointMassW",
  "binomialFracW", "normalPointMassW"), funcG0.uni = c("linUni", "polyUni",
  "sinUni", "jumpUni", "pLogisUni", "dNormUni", "qGammaUni", "dNormMixUni",
  "cubicSplineUni", "linSplineUni"), funcG0.biv = c("linBiv", "polyBiv",
  "sinBiv", "jumpBiv", "dNormAddBiv", "dNormMultBiv", "polyJumpBiv",
  "sinJumpBiv", "dNormMultJumpBiv", "linSplineBiv"), funcG0.tri = c("linTri",
  "polyTri", "sinTri", "jumpTri", "linJump2Tri", "linJump1Tri", "polyJump2Tri",
  "polyJump1Tri", "sinJump2Tri", "sinJump1Tri", "dNormAddTri", "dNormMultTri",
  "dNormMultJump2Tri", "dNormMultJump1Tri", "pLogisAddTri"),
  funcG0.quad = c("linQuad", "polyQuad", "sinQuad", "jumpQuad",
  "linJump2Quad", "linJump1Quad", "polyJump2Quad", "polyJump1Quad",
  "sinJump2Quad", "sinJump1Quad", "dNormAddQuad", "dNormMultQuad",
  "dNormMultJump2Quad", "dNormMultJump1Quad", "pLogisAddQuad"),
  funcQ0.uni = c("linUni", "polyUni", "sinUni", "jumpUni", "pLogisUni",
  "dNormUni", "qGammaUni", "dNormMixUni", "cubicSplineUni", "linSplineUni"),
  funcQ0.biv = c("linBiv", "polyBiv", "sinBiv", "jumpBiv", "dNormAddBiv",
  "dNormMultBiv", "polyJumpBiv", "sinJumpBiv", "dNormMultJumpBiv",
  "linSplineBiv"), funcQ0.tri = c("linTri", "polyTri", "sinTri", "jumpTri",
  "linJump2Tri", "linJump1Tri", "polyJump2Tri", "polyJump1Tri", "sinJump2Tri",
  "sinJump1Tri", "dNormAddTri", "dNormMultTri", "dNormMultJump2Tri",
  "dNormMultJump1Tri", "pLogisAddTri"), funcQ0.quad = c("linQuad", "polyQuad",
  "sinQuad", "jumpQuad", "linJump2Quad", "linJump1Quad", "polyJump2Quad",
  "polyJump1Quad", "sinJump2Quad", "sinJump1Quad", "dNormAddQuad",
  "dNormMultQuad", "dNormMultJump2Quad", "dNormMultJump1Quad", "pLogisAddQuad"),
  errY = c("normalErr", "uniformErr", "gammaErr", "normalErrAW",
  "uniformErrAW"), minG0 = 0.001, minR2 = 0.01, maxR2 = 0.99,
  pos = 0.005, skewing = c(-1, 1), ...)
}
\arguments{
\item{n}{A \code{numeric} sample size}

\item{maxD}{A \code{numeric} indicating maximum number of covariates}

\item{funcG0.uni}{A \code{vector} of \code{characters} that are functions in the global environment that
are used to generate main terms for logit of the propensity score.}

\item{funcG0.biv}{Ditto above, but for bivariate functions.}

\item{funcG0.tri}{Ditto above, but for trivariate functions.}

\item{funcQ0.uni}{Ditto \code{funcG0.uni}, but for the outcome regression}

\item{funcQ0.biv}{Ditto}

\item{funcQ0.tri}{Ditto}

\item{errY}{A \code{vector} of \code{characters} that are functions in the global environment that
are used to generate error terms for the outcome regression.}

\item{minG0}{The minimum value for the propensity score (default 0.01).}

\item{pos}{(1-2*pos)100\% of pscores fall withing minG0 and 1- minG0, default is .005}

\item{skewing}{default is c(-1,1). random add a skewing constant to the logit(pscores)}

\item{distW.uncor}{A \code{vector} of \code{characters} that are functions in the global environment that
generate covariates. These functions should have an associated parameter function with \code{"Parm"} added
to the end of their name. See the format of the functions provided to understand their structure.}

\item{distW.cor}{Same as above, but generates a correlated covariate}
}
\value{
An object of class \code{"makeRandomData"} with the following entries
\item{W}{A matrix of covariates}
\item{A}{A vector of binary treatments}
\item{Y}{A vector of continuously valued outcome}
\item{distW}{A list containing relevant information needed to reproduce data sets}
\item{fnG0}{A list of lists containing relevant information needed to reproduce data sets}
\item{fnQ0}{A list of lists containing relevant information needed to reproduce data sets}
\item{distErrY}{A list containing relevant information needed to reproduce data sets}
\item{divideLogitG0}{A numeric of the scaling factor for the propensity}
}
\description{
Simulate a random data generating distribution. See Details to see how it's done.
}
\details{
Draw random data generating distribution. The code simulates as follows: \cr
Simulate W \itemize{
\item Choose \code{D}, a random number of covariates from Uniform(1,maxD)
\item Randomly choose \code{d1}, the distribution for first covariate, from \code{distW.uncor}
\item Call \code{paste0(d1,".Parm")} (which is assumed to exist in the global environment) to get parameters for \code{d1}
\item Call \code{d1} with parameters chosen in previous step to generate first covariate
\item Randomly choose \code{d2}, the distribution for second covariate, from \code{c(distW.uncor, distW.cor)} (now including correlated distributions).
\item Call \code{paste0(d2,".Parm")} to get parameters for \code{d2}
\item Call \code{d2} with parameters chosen in previous step and first covariate (to possibly induce correlation with previous covariate) to generate second covariate.
\item Continue until \code{maxD} is reached.
}

Simulating A \itemize{
\item Draw \code{MG1}, a random number of main terms for propensity score, from Uniform(1,maxD)
\item For \code{i} = 1,...,\code{MG1}, draw \code{f} a random function from \code{funcG0.uni}
\item Call \code{paste0(f,"Parm")} (assumed to exist) to generate parameters for \code{f}
\item Call \code{f} with \code{x = W[,i]} to generate \code{i}-th main term.
\item If \code{D > 1}, draw \code{MG2}, a random number of bivariate interactions for propensity, from Uniform(1,\code{MG1-1})
\item For \code{i} = 1,...,\code{MG2}, draw \code{f} a random function from \code{funcG0.biv}
\item Call \code{paste0(f,"Parm")} (assumed to exist) to generate parameters for \code{f}
\item Draw \code{j} and \code{k}, two random columns of \code{W}
\item Call \code{f} with \code{x1 = W[,j], x2 = W[,k]} to generate \code{i}-th bivariate interaction term.
\item If \code{D > 2}, draw \code{MG3}, a random number of trivariate interactions for propensity, from Uniform(1,\code{MG2-1})
\item For \code{i} = 1,...,\code{MG3}, draw \code{f} a random function from \code{funcG0.tri}
\item Call \code{paste0(f,"Parm")} (assumed to exist) to generate parameters for \code{f}
\item Draw \code{j},\code{k},\code{l}, three random columns of \code{W}
\item Call \code{f} with \code{x1 = W[,j], x2 = W[,k], x3 = W[,l]} to generate \code{i}-th trivariate interaction term.
\item Sum together all main, bivariate, and trivariate terms to get the logit propensity score.
\item Divide the logit propensity score by 1.01 until the minimum propensity score is bigger than \code{minG0}.
\item Draw A from Bernoulli distribution with conditional probability equal to the adjusted propensity score.
}

Simulating Y \itemize{
\item Draw \code{MQ1}, a random number of main terms for outcome regression score, from Uniform(2,maxD)
\item For \code{i} = 1,...,\code{MQ1}, draw \code{f} a random function from \code{funcQ0.uni}
\item Call \code{paste0(f,"Parm")} (assumed to exist) to generate parameters for \code{f}
\item Call \code{f} with \code{x = AW[,i]} to generate \code{i}-th main term, where AW is matrix with first column A, other columns W.
\item If \code{D > 1}, draw \code{MQ2}, a random number of bivariate interactions for outcome regression, from Uniform(1,\code{MQ1-1})
\item For \code{i} = 1,...,\code{MQ2}, draw \code{f} a random function from \code{funcQ0.biv}
\item Call \code{paste0(f,"Parm")} (assumed to exist) to generate parameters for \code{f}
\item Draw \code{j} and \code{k}, two random columns of \code{W}
\item Call \code{f} with \code{x1 = W[,j], x2 = W[,k]} to generate \code{i}-th bivariate interaction term.
\item If \code{D > 2}, draw \code{MQ3}, a random number of trivariate interactions for propensity, from Uniform(1,\code{MQ2-1})
\item For \code{i} = 1,...,\code{MQ3}, draw \code{f} a random function from \code{funcQ0.tri}
\item Call \code{paste0(f,"Parm")} (assumed to exist) to generate parameters for \code{f}
\item Draw \code{j},\code{k},\code{l}, three random columns of \code{W}
\item Call \code{f} with \code{x1 = W[,j], x2 = W[,k], x3 = W[,l]} to generate \code{i}-th trivariate interaction term.
\item Sum together all main, bivariate, and trivariate terms to get the conditional mean outcome, \code{Q0}.
\item Draw \code{errf}, arandom function from \code{errY} from which to draw errors
\item Call \code{paste0(errf,"Parm"} (assumed to exist) to generate random parameters for error distribution.
\item Call \code{errf} with randomly chosen parameters to draw \code{e}, an error for the outcome.
\item Let \code{Y = Q0 + e}.
}
}
\examples{
# Generate a random distribution with max vars 8, up to 4-way interactions will be randomly created with
# these variables. a randomly drawn number to skewing the pscore distribution, 100(1 - pos)\% of pscores
# fall within minG0 and 1 - minG0

# right now it limits 2, 3 or 4 way interactions to be at most the number of main terms.
exD = makeRandomDataT(n=1000, maxD=10, minD = 2, minObsA = 300, minG0 = 0.05, pos = 0.05, skewing = c(-1,1))
# undebug(makeRandomDataT)
exD$its
exD$ct

mean(exD$A)
head(exD$W)
# number of iterations to control positivity-max is 20
exD$its
exD$skewage*.6^exD$its

# pscores
hist(exD$g0, 100)

# barQ
hist(exD$Q0, 100)

# max and min pscore, new then old
c(max(exD$g0), min(exD$g0))

#remake the data set according to the same specs randomly chosen!
exD_1 = remakeRandomDataT(1000, exD)
# undebug(remakeRandomDataT)
# pscores
hist(exD_1$g0, 100)
hist(exD$g0, 100)

mean(exD_1$g0)
mean(exD_1$A)
hist(exD$g0, 100)
mean(exD$g0)

# barQ
hist(exD_1$Q0, 100)

# max and min pscore, new then old
c(max(exD_1$g0), min(exD_1$g0))

}
